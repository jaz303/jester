//
//

{
	var A = require('./ast');

	var npStack = [true];

	function pushNP() {
		npStack.push(true);
		return true;
	}

	function popNP() {
		npStack.pop();
		return true;
	}

	function canNP() {
		return npStack[npStack.length-1];
	}

	function enterNP() {
		if (!canNP()) return false;
		npStack[npStack.length-1] = false;
		return true;
	}

	function exitNP() {
		npStack[npStack.length-1] = true;
		return true;
	}
}

Start
	= Module

//
// Tokens

NL 				= '\n' / '\r' '\n'?

LE				= '<='
GE				= '>='
LSHIFT			= '<<'
RSHIFT			= '>>'
EQ				= '='
NEQ 			= '!='
MISSING_ARG		= '?'
POW 			= '**'
LOGICAL_OR		= '||'
LOGICAL_AND		= '&&'
BITWISE_OR		= '|' !'|'
BITWISE_AND		= '&' !'&'
NO_CALL 		= BITWISE_AND
BITWISE_NOT		= '~'
BITWISE_XOR 	= '^'
LAMBDA_START	= '.['
DOT 			= '.' !'['
COMMA			= ','
SEMI			= ';'
ASSIGN 			= ':='
MINUS			= '-'
PLUS			= '+'
TIMES			= '*' !'*'
DIVIDE			= '/'
MOD				= '%'
BANG			= '!' ![=]
LT 				= '<' ![=<]
GT				= '>' ![=>]
LBRACE			= '{'
RBRACE			= '}'
LBRACKET		= '['
RBRACKET		= ']'
LPAREN			= '('
RPAREN			= ')'
GLOBAL 			= '$' !ident_start

//
// Keywords

DEF				= 'def'			!ident_rest
ELSE			= 'else' 		!ident_rest
EVAL			= 'eval'		!ident_rest
EXPORT			= 'export'		!ident_rest
EXPORT_B		= 'export!'
FALSE			= 'false'		!ident_rest
FOR				= 'for'			!ident_rest
IF				= 'if' 			!ident_rest
IMPORT			= 'import'		!ident_rest
IMPORT_B		= 'import!'
IN 				= 'in'			!ident_rest
LOOP			= 'loop'		!ident_rest
MY				= 'my'			!ident_rest
NULL			= 'null'		!ident_rest
RETURN			= 'return' 		!ident_rest
SPAWN			= 'spawn' 		!ident_rest
TRACE			= 'trace'		!ident_rest
TRUE			= 'true'		!ident_rest
WAIT			= 'wait'		!ident_rest
WHILE			= 'while'		!ident_rest
YIELD			= 'yield'		!ident_rest

Keyword
	= DEF
	/ ELSE
	/ EVAL
	/ EXPORT
	/ EXPORT_B
	/ FALSE
	/ FOR
	/ IF
	/ IMPORT
	/ IMPORT_B
	/ IN
	/ LOOP
	/ MY
	/ NULL
	/ RETURN
	/ SPAWN
	/ TRACE
	/ TRUE
	/ WAIT
	/ WHILE
	/ YIELD

//
// Helpers

_
	= [ \t]*

__
	= [ \t\r\n]*

// this denotes the whitespace permitted between a block statement's
// expression and subsequent brace
_b
	= __

// any characters that can be skipped including empty statements
_s
	= [ \t\r\n;]*

ident_start
	= [a-zA-Z]

ident_rest
	= [a-z0-9_]

ident
	= $( ident_start ident_rest* )

method_name
	= $( ident method_name_modifier? )

method_name_modifier
	= '!'
	/ '?'

non_zero_digit
	= [1-9]

digit
	= [0-9]

integer
	= $( non_zero_digit digit* )
	/ $( '0' ) !digit !'x' !'b'

float
	= $( integer '.' digit+ )

hex
	= $( '0x' [0-9a-f]i+ )

binary
	= $( '0b' [01]+ )

//
// Expressions

UnaryOperator
    = PLUS
    / MINUS
    / BITWISE_NOT
    / BANG
    / NO_CALL

MultiplicativeOperator
    = TIMES
    / DIVIDE
    / MOD
    / POW

AdditiveOperator
    = PLUS
    / MINUS

ShiftOperator
    = LSHIFT
    / RSHIFT

RelationalOperator
    = LE
    / GE
    / LT
    / GT

EqualityOperator
    = EQ
    / NEQ

BitwiseAndOperator
    = BITWISE_AND

BitwiseXorOperator
    = BITWISE_XOR

BitwiseOrOperator
    = BITWISE_OR

LogicalAndOperator
    = LOGICAL_AND

LogicalOrOperator
    = LOGICAL_OR

/* Expression */

Expression
    = AssignmentExpression

AssignmentExpression
    = l:LeftHandSideExpression _ ASSIGN _ r:AssignmentExpression {
        //var exp = new A.AssignExp();
        //exp.setLeft(l);
        //exp.setRight(r);
        //return exp;
    }
    / LogicalOrExpression

LogicalOrExpression
    = head:LogicalAndExpression rest:( LogicalOrOperator _ LogicalAndExpression )* {
        //return makeBinaryOperator(head, rest);
    }

LogicalAndExpression
    = head:BitwiseOrExpression rest:( LogicalAndOperator _ BitwiseOrExpression )* {
        //return makeBinaryOperator(head, rest);
    }

BitwiseOrExpression
    = head:BitwiseXorExpression rest: ( BitwiseOrOperator _ BitwiseXorExpression )* {
        //return makeBinaryOperator(head, rest);
    }

BitwiseXorExpression
    = head:BitwiseAndExpression rest: ( BitwiseXorOperator _ BitwiseAndExpression )* {
        //return makeBinaryOperator(head, rest);
    }

BitwiseAndExpression
    = head:EqualityExpression rest: ( BitwiseAndOperator _ EqualityExpression )* {
        //return makeBinaryOperator(head, rest);
    }

EqualityExpression
    = head:RelationalExpression rest: ( EqualityOperator _ RelationalExpression )* {
        //return makeBinaryOperator(head, rest);
    }

RelationalExpression
    = head:ShiftExpression rest: ( RelationalOperator _ ShiftExpression )* {
        //return makeBinaryOperator(head, rest);
    }

ShiftExpression
    = head:AdditiveExpression rest: ( ShiftOperator _ AdditiveExpression )* {
        //return makeBinaryOperator(head, rest);
    }

AdditiveExpression
    = head:MultiplicativeExpression rest: ( AdditiveOperator _ MultiplicativeExpression )* {
        //return makeBinaryOperator(head, rest);
    }

MultiplicativeExpression
    = head:UnaryExpression rest: ( MultiplicativeOperator _ UnaryExpression )* {
        //return makeBinaryOperator(head, rest);
    }

UnaryExpression
    = LeftHandSideExpression
    / op:UnaryOperator _ exp:UnaryExpression {
        //return new A.UnaryOpExp(op, exp);
    }

LeftHandSideExpression
    = CallExpression
    / CallNoParenExpression
    / MemberExpression

CallExpression
    = SPAWN? _ callee:MemberExpression args:Arguments rest:(CallCons)* {
        //var result = new A.CallExp(callee, args);
        //rest.forEach(function(r) {
        //    if (Array.isArray(r)) {
        //        result = new A.CallExp(result, r);
        //    } else if (r.computed) {
        //        result = new A.ComputedMemberExp(result, r.property);
        //    } else {
        //        result = new A.StaticMemberExp(result, r.property);
        //    }
        //});
        //return result;
    }

CallNoParenExpression
	= SPAWN? _ callee:MemberExpression
		&CNPStartToken
		&{ return enterNP(); }
		args:ArgumentList
		&{ return exitNP(); } {

	}

// An exhaustive list of valid tokens that can appear at the start
// of a function call with no parens
CNPStartToken
	= MISSING_ARG
	/ BITWISE_NOT
	/ LAMBDA_START
	/ BANG
	/ LBRACE
	/ GLOBAL
	/ TRUE
	/ FALSE
	/ TRACE
	/ NumericLiteral
	/ StringLiteral
	/ ColorLiteral
	/ Ident
	/ GlobalIdent

Arguments
	= '(' _ ')' _ {
        //return [];
    }
    / '(' &{ return pushNP(); } _ args:ArgumentList ')' &{ return popNP(); } _ {
        //return args;
    }
    

ArgumentList
    = head:Argument rest:( ',' _ Argument )* {
        //return [head].concat(rest.map(function(r) { return r[2]; }));
    }

Argument
	= Expression
	/ MISSING_ARG _

CallCons
    = Arguments
    / Member

MemberExpression
    = first:Primary rest:Member* {
        //var result = first;
        //rest.forEach(function(r) {
        //    if (r.computed) {
        //        result = new A.ComputedMemberExp(result, r.property);
        //    } else {
        //        result = new A.StaticMemberExp(result, r.property);
        //    }
        //});
        //return result;
    }

Member
    = ComputedMember
    / StaticMember

ComputedMember
    = '[' _ property:Expression ']' _ {
        return { computed: true, property: property };
    }

StaticMember
    = '.' _ property:ident _ {
        return { computed: false, property: property };
    }

//
// Atoms

Primary
	= Atom
	/ Lambda

Atom
	= Constant _
	/ Ident _
	/ GlobalObject _
	/ GlobalIdent _
	/ ArrayLiteral _
	/ DictionaryLiteral _
	/ '(' &{ return pushNP(); } _ exp:Expression _ ')' &{ return popNP(); } _

Constant
	= NumericLiteral
	/ StringLiteral _
	/ ColorLiteral _
	/ BooleanLiteral _

NumericLiteral
	= FloatLiteral _
	/ IntegerLiteral _
	/ HexLiteral _
	/ BinaryLiteral _

IntegerLiteral
	= v:integer {
		return parseInt(v, 10);
	}

HexLiteral
	= v:hex {
		return parseInt(v.substr(2), 16);
	}

BinaryLiteral
	= v:binary {
		return parseInt(v.substr(2), 2);
	}

FloatLiteral
	= v:float {
		return parseFloat(v.substr(2));
	}

StringLiteral
	= DoubleQuotedString

DoubleQuotedString
	= '"' str:(DoubleQuotedStringChar*) '"' {
		console.log(str.join(''));
	}

DoubleQuotedStringChar
	= "\\n"     { return "\n"; }
	/ "\\r"     { return "\r"; }
	/ "\\t"     { return "\t"; }
	/ "\\'"     { return "'"; }
	/ '\\"'     { return '"'; }
	/ '\\\\'    { return "\\"; }
	/ $ ( !["\\] . )

ColorLiteral
	= HexColorLiteral
	/ NamedColorLiteral

HexColorLiteral
	= '#' v:$( [0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f] ) {
		return A.hexColor('FF' + v);
	}
	/ '#' v:$( [0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f] ) {
		return A.hexColor(v);
	}

NamedColorLiteral
	= '#' name:$( [a-z]i+ ) {
		return A.namedColor(name);
	}

BooleanLiteral
	= TRUE { return true; }
	/ FALSE { return false; }

Ident
	= ident:$( ident ) {
		return A.ident(ident);
	}

GlobalObject
	= GLOBAL

GlobalIdent
	= '$' ident:ident {
		return A.globalIdent(ident);
	}

ArrayLiteral
	= '[' _ items:ArrayLiteralInner? ']' _ {

	}

ArrayLiteralInner
	= head:Expression _ tail:(',' _ Expression)* {
		return [head].concat(tail.map(function(i) {
			return i[2];
		}));
	}

DictionaryLiteral
	= '{' _ items:DictionaryLiteralInner? '}' _ {

	}

DictionaryLiteralInner
	= head:DictionaryPair _ tail:(',' _ DictionaryPair)* {

	}

DictionaryPair
	= DictionaryKey _ ':' _ Expression

DictionaryKey
	= Ident
	/ StringLiteral

//
//

Lambda
	= LAMBDA_START _ LambdaArgs? &{ return pushNP(); } Statements RBRACKET &{ return popNP(); }

LambdaArgs
	= Ident _ (',' _ Ident _)* '|'

//
// Productions

Module
	= __ Ports Statements

Ports
	= (Port NL)*

Port
	= Import
	/ ImportBang
	/ Export
	/ ExportBang

Import
	= IMPORT _ ident _ ImportSpecifics? PortAlias?

ImportBang
	= IMPORT_B _ ident _ ImportSpecifics?

ImportSpecifics
	= DOT _ LBRACE _ PortList RBRACE _

Export
	= EXPORT _ PortList

ExportBang
	= EXPORT_B _ ident

PortList
	= head:(PortItem) tail:(',' _ PortItem)*

PortItem
	= ident _ PortAlias?

PortAlias
	= 'as' _ ident _

Statements
	= _s Statement*

Statement
	= BlockStatement
	/ InlineStatement InlineStatementTerminator

Block
	= '{' Statements '}' _s

BlockStatement
	= WhileStatement
	/ LoopWhileStatement
	/ LoopStatement
	/ ForStatement
	/ ForeachStatement
	/ IfStatement
	/ FunctionDefinition

WhileStatement
	= WHILE _ Expression _b Block

LoopWhileStatement
	= LOOP _ WHILE _ Expression _b Block

LoopStatement
	= LOOP _b Block

ForStatement
	= FOR _ Ident _ IN _ Expression _ 'to' _ Expression _ ('step' _ Expression)? _b Block

ForeachStatement
	= FOR _ Ident _ (',' _ Ident _)? IN _ Expression _b Block

IfStatement
	= IF _ Expression _b Block ElseIfBlock* ElseBlock?

ElseIfBlock
	= _b ELSE _ IF _ Expression _b Block

ElseBlock
	= _b ELSE _b Block

FunctionDefinition
	= DEF _ method_name _ FunctionParameters? _b Block

FunctionParameters
	= '(' _ FunctionParameterList? ')'

FunctionParameterList
	= FunctionRequiredParameters (',' _ FunctionOptionalParameters)?
	/ FunctionOptionalParameters

FunctionRequiredParameters	= FRP (',' _ FRP)*
FunctionOptionalParameters	= FOP (',' _ FOP)*
					FRP 	= Ident _ !'='
					FOP 	= Ident _ '=' _ FOPExpr

FOPExpr
	= Constant

InlineStatement
	= ReturnStatement
	/ YieldStatement
	/ LocalVariables
	/ ExpressionStatement

// Inline statement ends with either a newline,
// semicolon, or if the end of the enclosing
// block/lambda is encountered.
InlineStatementTerminator
	= NL __
	/ SEMI __
	/ &'}'
	/ &']'

ReturnStatement
	= RETURN _ Expression _
	/ RETURN _

YieldStatement
	= YIELD _

LocalVariables
	= MY LocalVariable (',' _ LocalVariable)*

LocalVariable
	= Ident _ '=' _ Expression _
	/ Ident _

ExpressionStatement
	= Expression _
