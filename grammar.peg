/*
 * TODO
 *
 * Binary expressions
 * Unary expressions
 * If statement
 * Array deref
 * Dict deref
 */

/*
 * Entry
 */

start
    = body:Statements EOF {
        return body;
    }

/*
 * Helpers
 */

ws
    = [\t\v\f \u00A0\uFEFF]

identifier_start
    = [a-zA-Z_]

identifier_rest
    = [a-zA-Z0-9_]

/*
 * Tokens
 */

WHILE           = "while"       !identifier_rest
LOOP            = "loop"        !identifier_rest
FOREACH         = "foreach"     !identifier_rest
IN              = "in"          !identifier_rest
DEF             = "def"         !identifier_rest
TRUE            = "true"        !identifier_rest
FALSE           = "false"       !identifier_rest
YIELD           = "yield"       !identifier_rest
WAIT            = "wait"        !identifier_rest
SPAWN           = "spawn"       !identifier_rest
IF              = "if"          !identifier_rest
ELSE            = "else"        !identifier_rest
TRACE           = "trace"       !identifier_rest

_
    = ( ws )*

NL
    = "\n"
    / "\r\n"
    / "\r"

ST
    = _ ( NL / ";" ) _

EOF
    = !.

__
    = ( ws / NL )*

Integer
    = head:[1-9] tail:[0-9_]* {
        return head + tail.join('');
    }

Name
    = start:identifier_start rest:identifier_rest* {
        return start + rest.join('');
    }

/*
 * Productions
 */

Statements
    = ST* body:(StatementsInner)? ST* {
        return body || [];
    }

StatementsInner
    = head:LeadingStatements tail:TrailingStatement {
        head.push(tail);
        return head;
    }
    / body:LeadingStatements {
        return body;
    }
    / stmt:TrailingStatement {
        return [stmt];
    }

LeadingStatements
    = head:LeadingStatement tail:LeadingStatement* {
        var result = [head];
        for (var i = 0; i < tail.length; i++) {
            result.push(tail[i]);
        }
        return result;
    }

LeadingStatement
    = stmt:BlockStatement ST*   { return stmt; }
    / stmt:InlineStatement ST+  { return stmt; }

TrailingStatement
    = BlockStatement
    / InlineStatement

BlockStatement
    = WhileStatement
    / LoopWhileStatement
    / LoopStatement
    / ForeachStatement
    / FunctionDefinition

InlineStatement
    = Exp

WhileStatement
    = WHILE _ cond:Exp __ body:Block {
        return {
            type: 'while',
            condition: cond,
            body: body
        };
    }

LoopWhileStatement
    = LOOP _ WHILE _ cond:Exp __ body:Block {
        return {
            type: 'loop',
            condition: cond,
            body: body
        };
    }

LoopStatement
    = LOOP __ body:Block {
        return {
            type: 'loop',
            condition: true,
            body: body
        };
    }

ForeachStatement
    = FOREACH _ value:Name _ IN _ subject:Exp __ body:Block {
        return {
            type        : 'foreach',
            index       : null,
            value       : value,
            subject     : subject,
            body        : body
        }
    }
    / FOREACH _ index:Name _ ',' _ value:Name _ IN _ subject:Exp __ body:Block {
        return {
            type        : 'foreach',
            index       : index,
            value       : value,
            subject     : subject,
            body        : body
        };
    }

FunctionDefinition
    = DEF _ name:Name _ params:FunctionParameters? __ body:Block {
        return {
            type        : 'def',
            name        : name,
            params      : params || [],
            body        : body
        };
    }

FunctionParameters
    = '(' _ req:RequiredFunctionParameters opt:(',' _ OptionalFunctionParameters)? ')' {
        var params = req;
        if (opt) {
            for (var i = 0; i < opt[2].length; ++i) {
                params.push(opt[2][i]);
            }
        }
        return params;
    }
    / '(' _ req:RequiredFunctionParameters ')' {
        return req;
    }
    / '(' _ opt:OptionalFunctionParameters ')' {
        return opt;
    }

RequiredFunctionParameters
    = head:RequiredFunctionParameter tail:(',' _ RequiredFunctionParameter)* {
        var params = [head];
        for (var i = 0; i < tail.length; ++i) {
            params.push(tail[i][2]);
        }
        return params;
    }

RequiredFunctionParameter
    = name:Name _ !'=' {
        return {
            name: name
        };
    }

OptionalFunctionParameters
    = head:OptionalFunctionParameter tail:(',' _ OptionalFunctionParameter)* {
        var params = [head];
        for (var i = 0; i < tail.length; ++i) {
            params.push(tail[i][2]);
        }
        return params;
    }

OptionalFunctionParameter
    = name:Name _ '=' _ value:Literal _ {
        return {
            name: name,
            value: value
        };
    }

Block
    = "{" __ body:Statements __ "}" {
        return body;
    }

Exp
    = Atom
    / Lambda

Atom
    = Literal
    / Ident

Literal
    = Integer
    / TRUE      { return true; }
    / FALSE     { return false; }

Ident
    = name:Name {
        return {type: 'ident', name: name};
    }

Lambda
    = ".{" _ args:(LambdaArgs _ "|" _)? body:Statements _ "}" {
        return {
            type: 'lambda',
            args: args ? args[0] : [],
            body: body
        }
    }
    
LambdaArgs
    = head:Name tail:(_ "," _ Name)* {
        var result = [head];
        for (var i = 0; i < tail.length; ++i) {
            result.push(tail[i][3]);
        }
        return result;
    }

LiteralArray
    = '[' _ ']' {
        return {
            type    : 'array',
            values  : []
        }
    }
    / '[' _ head:Exp tail:(',' _ Exp)* ']' {
        var values = [head];
        for (var i = 0; i < tail.length; ++i) {
            values.push(tail[i][2]);
        }
        return {
            type    : 'array',
            values  : values
        };
    }

LiteralDict
    = '{' _ '}' {
        return {
            type    : 'dict',
            pairs   : [],
        };
    }
    / '{' _ head:Pair tail:(',' _ Pair)* '}' {
        var pairs = [head];
        for (var i = 0; i < tail.length; ++i) {
            pairs.push(tail[i][2]);
        }
        return {
            type    : 'dict',
            pairs   : pairs
        };
    }

Pair
    = name:Name _ '=' _ value:Exp _ {
        return [name, value];
    }
