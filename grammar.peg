/*
 * TODO
 *
 * Binary expressions
 * Unary expressions
 * If statement
 * Array deref
 * Dict deref
 * Color constructors
 * Vectors
 */

/*
 * Entry
 */

start
    = body:Statements EOF {
        return body;
    }

/*
 * Helpers
 */

ws
    = [\t\v\f \u00A0\uFEFF]

identifier_start
    = [a-zA-Z_]

identifier_rest
    = [a-zA-Z0-9_]

bin_digit
    = [01]

hex_digit
    = [0-9a-fA-F]

digit
    = [0-9]

non_zero_digit
    = [1-9]

/*
 * Tokens
 */

WHILE           = "while"       !identifier_rest
LOOP            = "loop"        !identifier_rest
FOREACH         = "foreach"     !identifier_rest
IN              = "in"          !identifier_rest
DEF             = "def"         !identifier_rest
TRUE            = "true"        !identifier_rest
FALSE           = "false"       !identifier_rest
YIELD           = "yield"       !identifier_rest
WAIT            = "wait"        !identifier_rest
SPAWN           = "spawn"       !identifier_rest
IF              = "if"          !identifier_rest
ELSE            = "else"        !identifier_rest
TRACE           = "trace"       !identifier_rest

_
    = ( ws )*

NL
    = "\n"
    / "\r\n"
    / "\r"

ST
    = _ ( NL / ";" ) _

EOF
    = !.

__
    = ( ws / NL )*

Name
    = start:identifier_start rest:identifier_rest* {
        return start + rest.join('');
    }

/*
 * Productions
 */

Statements
    = ST* body:(StatementsInner)? ST* {
        return body || [];
    }

StatementsInner
    = head:LeadingStatements tail:TrailingStatement {
        head.push(tail);
        return head;
    }
    / body:LeadingStatements {
        return body;
    }
    / stmt:TrailingStatement {
        return [stmt];
    }

LeadingStatements
    = head:LeadingStatement tail:LeadingStatement* {
        var result = [head];
        for (var i = 0; i < tail.length; i++) {
            result.push(tail[i]);
        }
        return result;
    }

LeadingStatement
    = stmt:BlockStatement ST*   { return stmt; }
    / stmt:InlineStatement ST+  { return stmt; }

TrailingStatement
    = BlockStatement
    / InlineStatement

BlockStatement
    = IfStatement
    / WhileStatement
    / LoopWhileStatement
    / LoopStatement
    / ForeachStatement
    / FunctionDefinition

InlineStatement
    = Exp

IfStatement
    = IF _ cond:Exp __ body:Block elif:ElseIf* el:Else? {
        var alts = [[cond, body]];
        for (var i = 0; i < elif.length; ++i) {
            alts.push(elif[i]);
        }
        if (el) {
            alts.push(el);
        }
        return {
            type    : 'if',
            clauses : alts
        };
    }

ElseIf
    = __ ELSE _ IF _ cond:Exp __ body:Block {
        return [cond, body];
    }

Else
    = __ ELSE __ body:Block __ {
        return [null, body];
    }

WhileStatement
    = WHILE _ cond:Exp __ body:Block {
        return {
            type        : 'while',
            condition   : cond,
            body        : body
        };
    }

LoopWhileStatement
    = LOOP _ WHILE _ cond:Exp __ body:Block {
        return {
            type: 'loop',
            condition: cond,
            body: body
        };
    }

LoopStatement
    = LOOP __ body:Block {
        return {
            type: 'loop',
            condition: true,
            body: body
        };
    }

ForeachStatement
    = FOREACH _ value:Name _ IN _ subject:Exp __ body:Block {
        return {
            type        : 'foreach',
            index       : null,
            value       : value,
            subject     : subject,
            body        : body
        }
    }
    / FOREACH _ index:Name _ ',' _ value:Name _ IN _ subject:Exp __ body:Block {
        return {
            type        : 'foreach',
            index       : index,
            value       : value,
            subject     : subject,
            body        : body
        };
    }

FunctionDefinition
    = DEF _ name:Name _ params:FunctionParameters? __ body:Block {
        return {
            type        : 'def',
            name        : name,
            params      : params || [],
            body        : body
        };
    }

FunctionParameters
    = '(' _ req:RequiredFunctionParameters opt:(',' _ OptionalFunctionParameters)? ')' {
        var params = req;
        if (opt) {
            for (var i = 0; i < opt[2].length; ++i) {
                params.push(opt[2][i]);
            }
        }
        return params;
    }
    / '(' _ req:RequiredFunctionParameters ')' {
        return req;
    }
    / '(' _ opt:OptionalFunctionParameters ')' {
        return opt;
    }

RequiredFunctionParameters
    = head:RequiredFunctionParameter tail:(',' _ RequiredFunctionParameter)* {
        var params = [head];
        for (var i = 0; i < tail.length; ++i) {
            params.push(tail[i][2]);
        }
        return params;
    }

RequiredFunctionParameter
    = name:Name _ !'=' {
        return {
            name: name
        };
    }

OptionalFunctionParameters
    = head:OptionalFunctionParameter tail:(',' _ OptionalFunctionParameter)* {
        var params = [head];
        for (var i = 0; i < tail.length; ++i) {
            params.push(tail[i][2]);
        }
        return params;
    }

OptionalFunctionParameter
    = name:Name _ '=' _ value:Literal _ {
        return {
            name: name,
            value: value
        };
    }

Block
    = "{" __ body:Statements __ "}" {
        return body;
    }

Exp
    = Atom
    / Lambda

Atom
    = Literal
    / Ident

Literal
    = Number
    / Color
    / TRUE      { return true; }
    / FALSE     { return false; }

Ident
    = name:Name {
        return {type: 'ident', name: name};
    }

Number
    = Float
    / Integer
    / Binary
    / Hex

Float
    = rhead:digit rtail:(digit / '_')* '.' ftail:(digit / '_')+ {
        return {
            type    : 'float',
            value   : rhead + rtail.join('') + '.' + ftail.join('')
        };
    }

Integer
    = head:non_zero_digit tail:(digit / '_')* {
        return head + tail.join('');
    }

Binary
    = '0b' head:bin_digit tail:(bin_digit / '_')* {
        return {
            type    : 'binary',
            value   : head + tail.join('')
        };
    }

Hex
    = '0x' head:hex_digit tail:(hex_digit / '_')* {
        return {
            type    : 'hex',
            value   : head + tail.join('')
        };
    }

Color
    = HexColor
    / NamedColor

HexColor
    = '#' red:HexComp green:HexComp blue:HexComp alpha:HexComp {
        return {
            type    : 'color',
            red     : red,
            green   : green,
            blue    : blue,
            alpha   : alpha
        }
    }
    / '#' red:HexComp green:HexComp blue:HexComp {
        return {
            type    : 'color',
            red     : red,
            green   : green,
            blue    : blue,
            alpha   : 255
        }
    }

HexComp
    = d1:hex_digit d2:hex_digit {
        return parseInt(d1 + d2, 16);
    }

NamedColor
    = '#' name:Name {
        return {
            type    : 'named-color',
            name    : name
        }
    }

Lambda
    = ".{" _ args:(LambdaArgs _ "|" _)? body:Statements _ "}" {
        return {
            type: 'lambda',
            args: args ? args[0] : [],
            body: body
        }
    }
    
LambdaArgs
    = head:Name tail:(_ "," _ Name)* {
        var result = [head];
        for (var i = 0; i < tail.length; ++i) {
            result.push(tail[i][3]);
        }
        return result;
    }

LiteralArray
    = '[' _ ']' {
        return {
            type    : 'array',
            values  : []
        }
    }
    / '[' _ head:Exp tail:(',' _ Exp)* ']' {
        var values = [head];
        for (var i = 0; i < tail.length; ++i) {
            values.push(tail[i][2]);
        }
        return {
            type    : 'array',
            values  : values
        };
    }

LiteralDict
    = '{' _ '}' {
        return {
            type    : 'dict',
            pairs   : [],
        };
    }
    / '{' _ head:Pair tail:(',' _ Pair)* '}' {
        var pairs = [head];
        for (var i = 0; i < tail.length; ++i) {
            pairs.push(tail[i][2]);
        }
        return {
            type    : 'dict',
            pairs   : pairs
        };
    }

Pair
    = name:Name _ '=' _ value:Exp {
        return [name, value];
    }
